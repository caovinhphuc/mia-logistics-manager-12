import TelegramBot from 'node-telegram-bot-api'
import { notificationConfig } from '../config/notification.js'

class TelegramService {
  constructor() {
    this.bot = null
    this.isInitialized = false
    this.commandHandlers = new Map()
    this.init()
  }

  init() {
    if (!notificationConfig.telegram.token) {
      console.log('‚ö†Ô∏è Telegram Bot: CH∆ØA C·∫§U H√åNH TOKEN')
      return
    }

    try {
      if (notificationConfig.telegram.webhookUrl) {
        // Webhook mode for production
        this.bot = new TelegramBot(notificationConfig.telegram.token)
        this.setupWebhook()
      } else {
        // Polling mode for development
        this.bot = new TelegramBot(notificationConfig.telegram.token, {
          polling: true,
        })
        console.log('ü§ñ Telegram Bot: ‚úÖ ƒê√É KH·ªûI ƒê·ªòNG (Polling Mode)')
      }

      this.setupCommandHandlers()
      this.setupMessageHandlers()
      this.isInitialized = true
    } catch (error) {
      console.error('‚ùå Telegram Bot: L·ªñI KH·ªûI T·∫†O:', error)
    }
  }

  setupWebhook() {
    const hookUrl = `${notificationConfig.telegram.webhookUrl.replace(/\/$/, '')}/webhook/telegram`

    this.bot
      .setWebHook(hookUrl)
      .then(() => {
        console.log('‚úÖ Telegram webhook set:', hookUrl)
      })
      .catch((error) => {
        console.error('‚ùå Webhook setup error:', error.response?.body || error.message)
      })
  }

  setupCommandHandlers() {
    // Register command handlers
    this.registerCommand('/start', this.handleStart.bind(this))
    this.registerCommand('/help', this.handleHelp.bind(this))
    this.registerCommand('/status', this.handleStatus.bind(this))
    this.registerCommand('/carriers', this.handleCarriers.bind(this))
    this.registerCommand('/orders', this.handleOrders.bind(this))
    this.registerCommand('/report', this.handleReport.bind(this))
    this.registerCommand('/settings', this.handleSettings.bind(this))

    // Setup bot command listeners
    if (this.bot) {
      this.bot.on('message', (msg) => {
        this.handleMessage(msg)
      })
    }
  }

  setupMessageHandlers() {
    if (this.bot) {
      this.bot.on('message', (msg) => {
        const chatId = msg.chat?.id
        if (chatId) {
          console.log(`üì® [Telegram] Message from chatId: ${chatId}`)
        }
      })
    }
  }

  registerCommand(command, handler) {
    this.commandHandlers.set(command, handler)
  }

  handleMessage(msg) {
    const { text, chat } = msg
    if (!text || !chat) return

    const command = text.split(' ')[0].toLowerCase()
    const handler = this.commandHandlers.get(command)

    if (handler) {
      handler(msg)
    } else if (text.startsWith('/')) {
      this.sendMessage(chat.id, '‚ùå L·ªánh kh√¥ng ƒë∆∞·ª£c h·ªó tr·ª£. G√µ /help ƒë·ªÉ xem danh s√°ch l·ªánh.')
    }
  }

  async handleStart(msg) {
    const welcomeMessage = `üéâ *Ch√†o m·ª´ng ƒë·∫øn v·ªõi MIA Logistics Manager!*

ü§ñ T√¥i l√† bot h·ªó tr·ª£ qu·∫£n l√Ω logistics c·ªßa b·∫°n.

üìã *C√°c l·ªánh c√≥ s·∫µn:*
/help - Xem h∆∞·ªõng d·∫´n
/status - Tr·∫°ng th√°i h·ªá th·ªëng
/carriers - Th·ªëng k√™ nh√† v·∫≠n chuy·ªÉn
/orders - Th·ªëng k√™ ƒë∆°n h√†ng
/report - B√°o c√°o nhanh
/settings - C√†i ƒë·∫∑t th√¥ng b√°o

üí° G√µ /help ƒë·ªÉ bi·∫øt th√™m chi ti·∫øt!`

    await this.sendMessage(msg.chat.id, welcomeMessage)
  }

  async handleHelp(msg) {
    const helpMessage = `üìö *H∆∞·ªõng d·∫´n s·ª≠ d·ª•ng MIA Logistics Bot*

üîß *L·ªánh c∆° b·∫£n:*
/start - Kh·ªüi ƒë·ªông bot
/help - Hi·ªÉn th·ªã h∆∞·ªõng d·∫´n n√†y
/status - Ki·ªÉm tra tr·∫°ng th√°i h·ªá th·ªëng

üìä *L·ªánh th·ªëng k√™:*
/carriers - Xem th·ªëng k√™ nh√† v·∫≠n chuy·ªÉn
/orders - Xem th·ªëng k√™ ƒë∆°n h√†ng
/report - B√°o c√°o t·ªïng quan

‚öôÔ∏è *L·ªánh c√†i ƒë·∫∑t:*
/settings - C√†i ƒë·∫∑t th√¥ng b√°o

üì± *Th√¥ng b√°o t·ª± ƒë·ªông:*
‚Ä¢ C·∫≠p nh·∫≠t nh√† v·∫≠n chuy·ªÉn
‚Ä¢ Thay ƒë·ªïi tr·∫°ng th√°i ƒë∆°n h√†ng
‚Ä¢ B√°o c√°o h√†ng ng√†y/tu·∫ßn/th√°ng
‚Ä¢ C·∫£nh b√°o h·ªá th·ªëng

üí¨ *H·ªó tr·ª£:* Li√™n h·ªá admin n·∫øu c·∫ßn h·ªó tr·ª£ th√™m.`

    await this.sendMessage(msg.chat.id, helpMessage)
  }

  async handleStatus(msg) {
    const statusMessage = `üü¢ *Tr·∫°ng th√°i H·ªá th·ªëng*

üìä **T·ªïng quan:**
‚Ä¢ Nh√† v·∫≠n chuy·ªÉn: 2 (1 active)
‚Ä¢ ƒê∆°n h√†ng: 0
‚Ä¢ H·ªá th·ªëng: Ho·∫°t ƒë·ªông b√¨nh th∆∞·ªùng

‚è∞ **C·∫≠p nh·∫≠t l·∫ßn cu·ªëi:** ${new Date().toLocaleString('vi-VN')}

üîî **Th√¥ng b√°o:** ƒêang ho·∫°t ƒë·ªông
üìß **Email:** ${notificationConfig.email.sendgrid.enabled ? '‚úÖ' : '‚ùå'}
üåê **Webhook:** ${notificationConfig.telegram.webhookUrl ? '‚úÖ' : '‚ùå (Polling)'}`

    await this.sendMessage(msg.chat.id, statusMessage)
  }

  async handleCarriers(msg) {
    const carriersMessage = `üöö *Th·ªëng k√™ Nh√† v·∫≠n chuy·ªÉn*

üìã **T·ªïng s·ªë:** 2 nh√† v·∫≠n chuy·ªÉn

‚úÖ **ƒêang ho·∫°t ƒë·ªông:** 2
‚ùå **T·∫°m ng∆∞ng:** 0

üìä **Theo khu v·ª±c:**
‚Ä¢ To√†n qu·ªëc: 1
‚Ä¢ Mi·ªÅn Nam: 1

üí∞ **Theo ph∆∞∆°ng th·ª©c t√≠nh gi√°:**
‚Ä¢ PER_KM: 1
‚Ä¢ PER_M3: 1

üìà **ƒê√°nh gi√° trung b√¨nh:** 4.35/5.0`

    await this.sendMessage(msg.chat.id, carriersMessage)
  }

  async handleOrders(msg) {
    const ordersMessage = `üì¶ *Th·ªëng k√™ ƒê∆°n h√†ng*

üìã **T·ªïng s·ªë:** 0 ƒë∆°n h√†ng

üìä **Theo tr·∫°ng th√°i:**
‚Ä¢ Ch·ªù x·ª≠ l√Ω: 0
‚Ä¢ ƒêang v·∫≠n chuy·ªÉn: 0
‚Ä¢ ƒê√£ giao: 0
‚Ä¢ ƒê√£ h·ªßy: 0

üí∞ **Doanh thu h√¥m nay:** 0 VNƒê
üìà **So v·ªõi h√¥m qua:** 0%`

    await this.sendMessage(msg.chat.id, ordersMessage)
  }

  async handleReport(msg) {
    const reportMessage = `üìä *B√°o c√°o Nhanh - ${new Date().toLocaleDateString('vi-VN')}*

üöö **Nh√† v·∫≠n chuy·ªÉn:**
‚Ä¢ T·ªïng: 2
‚Ä¢ Active: 2
‚Ä¢ Inactive: 0

üì¶ **ƒê∆°n h√†ng:**
‚Ä¢ T·ªïng: 0
‚Ä¢ H√¥m nay: 0
‚Ä¢ Tu·∫ßn n√†y: 0

üí∞ **T√†i ch√≠nh:**
‚Ä¢ Doanh thu h√¥m nay: 0 VNƒê
‚Ä¢ Doanh thu tu·∫ßn: 0 VNƒê
‚Ä¢ Doanh thu th√°ng: 0 VNƒê

üìà **Hi·ªáu su·∫•t:**
‚Ä¢ T·ª∑ l·ªá giao h√†ng th√†nh c√¥ng: N/A
‚Ä¢ Th·ªùi gian giao h√†ng trung b√¨nh: N/A`

    await this.sendMessage(msg.chat.id, reportMessage)
  }

  async handleSettings(msg) {
    const settingsMessage = `‚öôÔ∏è *C√†i ƒë·∫∑t Th√¥ng b√°o*

üîî **K√™nh th√¥ng b√°o:**
‚Ä¢ Telegram: ‚úÖ
‚Ä¢ Email: ${notificationConfig.email.sendgrid.enabled ? '‚úÖ' : '‚ùå'}
‚Ä¢ Real-time: ‚úÖ

üìÖ **L·ªãch b√°o c√°o:**
‚Ä¢ H√†ng ng√†y: 8:00 AM ‚úÖ
‚Ä¢ H√†ng tu·∫ßn: Th·ª© 2, 9:00 AM ‚úÖ
‚Ä¢ H√†ng th√°ng: Ng√†y 1, 10:00 AM ‚úÖ

üîß **ƒê·ªÉ thay ƒë·ªïi c√†i ƒë·∫∑t:**
Li√™n h·ªá admin ƒë·ªÉ c·∫≠p nh·∫≠t c·∫•u h√¨nh.`

    await this.sendMessage(msg.chat.id, settingsMessage)
  }

  async sendMessage(chatId, text, options = {}) {
    if (!this.bot || !this.isInitialized) {
      console.error('‚ùå Telegram bot not initialized')
      return false
    }

    try {
      const defaultOptions = {
        disable_web_page_preview: true,
      }

      await this.bot.sendMessage(chatId, text, {
        ...defaultOptions,
        ...options,
      })
      return true
    } catch (error) {
      console.error('‚ùå Telegram send message error:', error)
      return false
    }
  }

  // Debug helper: return error details to caller
  async sendMessageDebug(chatId, text, options = {}) {
    if (!this.bot || !this.isInitialized) {
      return { ok: false, error: 'Telegram bot not initialized' }
    }
    try {
      const defaultOptions = { disable_web_page_preview: true }
      const res = await this.bot.sendMessage(chatId, text, {
        ...defaultOptions,
        ...options,
      })
      return { ok: true, result: res }
    } catch (error) {
      const errMsg = error?.response?.body || error?.message || String(error)
      return { ok: false, error: errMsg }
    }
  }

  async sendNotification(template, data, priority = 'medium') {
    const channels = notificationConfig.channels[priority] || notificationConfig.channels.medium

    if (channels.includes('telegram')) {
      const chatId = notificationConfig.telegram.chatId
      const message = this.formatTemplate(template, data)

      if (message) {
        await this.sendMessage(chatId, message)
      }
    }
  }

  formatTemplate(templateName, data) {
    const template = notificationConfig.templates[templateName]
    if (!template || !template.telegram) return null

    let message = template.telegram

    // Replace placeholders with actual data
    Object.keys(data).forEach((key) => {
      const placeholder = `{${key}}`
      message = message.replace(new RegExp(placeholder, 'g'), data[key] || 'N/A')
    })

    return message
  }

  // Webhook handler for production
  handleWebhook(req, res) {
    if (!this.bot) {
      return res.sendStatus(500)
    }

    try {
      this.bot.processUpdate(req.body)
      res.sendStatus(200)
    } catch (error) {
      console.error('‚ùå Webhook processing error:', error)
      res.sendStatus(500)
    }
  }

  // Get bot info
  getBotInfo() {
    return {
      isInitialized: this.isInitialized,
      hasToken: !!notificationConfig.telegram.token,
      webhookUrl: notificationConfig.telegram.webhookUrl,
      chatId: notificationConfig.telegram.chatId,
    }
  }
}

export default new TelegramService()
